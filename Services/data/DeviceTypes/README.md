Each **Simulated Device** belongs to a specific **Device Type**, which defines
the simulation behavior, for example how frequently telemetry is sent, what
kind of messages to send, which methods are supported, etc.

Device types are defined using JSON configuration files. Follows a description
of all the properties found in a typical device type definition file.

#### File schema

The schema version is always "1.0.0" and is specific to the format of this
file:
```json
"SchemaVersion": "1.0.0"
```

#### Device type description

The following properties describe the device type. Each type has a unique
identifier, a semantic version, a name and a description:
```json
"Id": "12345678-1234-1234-1234-123456789012",
"Version": "0.0.1",
"Name": "Chiller",
"Description": "Simulated Chiller with temperature and humidity sensors"
```

#### IoT Protocol

IoT devices can connect using different protocols. The simulation allows to
use either **AMQP, MQTT or HTTP**:
```json
"Protocol": "AMQP"
```

#### Generating telemetry and executing device logic

A typical simulation will **generate fake values**, in order to fake some
**behavior** and simulate some scenario. It's also possible to test workflows,
i.e. **reacting to commands and events** with multiple actions.

In order to generate these values and execute these actions, the simulation
engine relies on **custom logic, plugged in using external functions**. Each
function is defined in a Javascript file. For more information about
customizing or creating new function, see the "Javascript" folder.

The functions are listed with distinct names under `DeviceBehavior`, and
referenced later in the file, using the `${<name>...}` syntax. By convention,
functions returning data start with `get_`, and functions executing actions
start with `do_`:
```json
"DeviceBehavior": {
    "get_random_temperature": {
        "Type": "javascript",
        "Path": "random-temperature-celsius-sensor.js"
    },
    "get_random_percentage": {
        "Type": "javascript",
        "Path": "random-percentage-sensor.js"
    },
    "get_power_source": {
        "Type": "javascript",
        "Path": "chiller-power-sensors.js"
    },
    "do_reboot": {
        "Type": "javascript",
        "Path": "chiller-reboot-method.js"
    },
    "do_upgrade": {
        "Type": "javascript",
        "Path": "chiller-upgrade-method.js"
    }
}
```

#### Telemetry messages

Simulated devices will send one or more messages, with a defined format, using
the data generated by the functions described above.

The following block shows how a simulated device will send two types of
messages. The first is a simple text message sent every minute. The second is
a more realistic example showing how to send data generated by the functions
above, using a JSON object with eight fields of different types.

```json
"Telemetry": {
    "Messages": [
        {
            "Interval": "00:01:00",
            "Message": "test",
            "MessageSchema": {
                "Name": "chillertest;v1",
                "Format": "Text"
            }
        },
        {
            "Interval": "00:00:15",
            "Message":
                "{\"temperature\": ${get_random_temperature.value},\"t_unit\":\"C\",\"humidity\": ${get_random_percentage.value},\"h_unit\":\"%\",\"voltage\": ${get_power_source.voltage},\"v_unit\":\"${get_power_source.voltage_unit}\",\"power\": ${get_power_source.power},\"p_unit\":\"${get_power_source.power_unit}\"}",
            "MessageSchema": {
                "Name": "chiller;v1",
                "Format": "JSON",
                "Fields": {
                    "temperature": "double",
                    "humidity": "integer",
                    "voltage": "double",
                    "power": "double",
                    "t_unit": "text",
                    "h_unit": "text",
                    "v_unit": "text",
                    "p_unit": "text"
                }
            }
        }
    ]
}
```

##### Message format

The `message` property contains a template and may contain placeholders,
referencing functions listed under `DeviceBehavior`. References use the
following format:

`$(` + `function name` + `.` + `output value name` + `)`

The name of the output value depends on the function used. For example a
function with the following return statement:

`return { state: state, value1: 1, value2: 3, value3: 5 };`

will have references looking like these:

* `${get-some-data.value1}`
* `${get-some-data.value2}`
* `${get-some-data.value3}`

If one value is intended to be used as a text value, the message template
should surround the value with double quotes, to ensure that the JSON object
syntax is correct.

##### Message schema

Each message type must have a well defined schema. The message schema is
also published to IoT Hub, so that backend applications reuse this information
to interpret the incoming telemetry.

The schema is used also by the simulation engine, to serialize the values
generated by the custom functions.

The schema supports 3 formats:

* JSON (preferred)
* Text
* Binary

JSON allows for easy parsing, transformation and analytics, and is the
preferred format.

The fields listed in the schema can use the following types:

* Object
* Binary
* Text
* Boolean
* Integer
* Double
* DateTime

#### Supported methods

Simulated devices can also react to method calls, in which case they will
execute some logic and provide some response. The actions to take are listed
in the following configuration block. The output of each action is collected
and returned as in the method response.
```json
"CloudToDeviceMethods": {
    "Reboot": {
        "Actions": [
            "${do_reboot}"
        ]
    },
    "Upgrade": {
        "Actions": [
            "${do_reboot}",
            "${do_upgrade}",
            "${do_reboot}"
        ]
    }
}
```
