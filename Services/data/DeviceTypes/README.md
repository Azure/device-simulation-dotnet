<!-- https://github.com/Azure/device-simulation-dotnet/wiki/Device-Types -->

Each **Simulated Device** belongs to a specific **Device Type**, which defines
the simulation behavior, for example how frequently telemetry is sent, what
kind of messages to send, which methods are supported, etc.

**Device types** are defined using a set of JSON configuration files,
**one file for each device type**, and a set of **Javascript files containing
the functions** to generate the random data.

Given that device types are defined via configuration and script files, it is
possible to add new types and customize the data, without rebuilding the
service. For instance, in order to create a new device type, a new JSON
configuration file is added to the **device types folder** and the
microservice is re-deployed.

Each device type file contains the definition of the simulated device type,
including the following information:

* Device type name: string
* Protocol: AMQP | MQTT | HTTP
* How to generate the telemetry:
    * Frequency: how often to send a telemetry message
    * A template of the message, with placeholders for values to be generated
    * The schema of the message, used by backend applications to interpret
      the telemetry
* A list of supported methods

Some example of configuration and script files can be found in the service.

Device Type files
=================

#### File schema

The schema version is always "1.0.0" and is specific to the format of this
file:
```json
"SchemaVersion": "1.0.0"
```

#### Device type description

The following properties describe the device type. Each type has a unique
identifier, a semantic version, a name and a description:
```json
"Id": "12345678-1234-1234-1234-123456789012",
"Version": "0.0.1",
"Name": "Chiller",
"Description": "Simulated Chiller with temperature and humidity sensors"
```

#### IoT Protocol

IoT devices can connect using different protocols. The simulation allows to
use either **AMQP, MQTT or HTTP**:
```json
"Protocol": "AMQP"
```

#### Generating telemetry and executing device logic

A typical simulation will **generate fake values**, in order to fake some
**behavior** and simulate some scenario. It's also possible to test workflows,
i.e. **reacting to commands and events** with multiple actions.

In order to generate these values and execute these actions, the simulation
engine relies on **custom logic, plugged in using external functions**. Each
function is defined in a Javascript file. For more information about
customizing or creating new function, see the "Javascript" folder.

The functions are listed with distinct names under `DeviceBehavior`, and
referenced later in the file, using the `${<name>...}` syntax. By convention,
functions returning data start with `get_`, and functions executing actions
start with `do_`:
```json
"DeviceBehavior": {
    "get_random_temperature": {
        "Type": "javascript",
        "Path": "random-temperature-celsius-sensor.js"
    },
    "get_random_percentage": {
        "Type": "javascript",
        "Path": "random-percentage-sensor.js"
    },
    "get_power_source": {
        "Type": "javascript",
        "Path": "chiller-power-sensors.js"
    },
    "do_reboot": {
        "Type": "javascript",
        "Path": "chiller-reboot-method.js"
    },
    "do_upgrade": {
        "Type": "javascript",
        "Path": "chiller-upgrade-method.js"
    }
}
```

#### Telemetry messages

Simulated devices will send one or more messages, with a defined format, using
the data generated by the functions described above.

The following block shows how a simulated device will send two types of
messages. The first is a simple text message sent every minute. The second is
a more realistic example showing how to send data generated by the functions
above, using a JSON object with eight fields of different types.

```json
"Telemetry": {
    "Messages": [
        {
            "Interval": "00:01:00",
            "Message": "test",
            "MessageSchema": {
                "Name": "chillertest;v1",
                "Format": "Text"
            }
        },
        {
            "Interval": "00:00:15",
            "Message":
                "{\"temperature\": ${get_random_temperature.value},\"t_unit\":\"C\",\"humidity\": ${get_random_percentage.value},\"h_unit\":\"%\",\"voltage\": ${get_power_source.voltage},\"v_unit\":\"${get_power_source.voltage_unit}\",\"power\": ${get_power_source.power},\"p_unit\":\"${get_power_source.power_unit}\"}",
            "MessageSchema": {
                "Name": "chiller;v1",
                "Format": "JSON",
                "Fields": {
                    "temperature": "double",
                    "humidity": "integer",
                    "voltage": "double",
                    "power": "double",
                    "t_unit": "text",
                    "h_unit": "text",
                    "v_unit": "text",
                    "p_unit": "text"
                }
            }
        }
    ]
}
```

##### Message format

The `message` property contains a template and may contain placeholders,
referencing functions listed under `DeviceBehavior`. References use the
following format:

`${` + `function name` + `.` + `output value name` + `}`

The name of the output value depends on the function used. For example a
function with the following return statement:

`return { state: state, value1: 1, value2: 3, value3: 5 };`

will have references looking like these:

* `${get-some-data.value1}`
* `${get-some-data.value2}`
* `${get-some-data.value3}`

If one value is intended to be used as a text value, the message template
should surround the value with double quotes, to ensure that the JSON object
syntax is correct.

##### Message schema

Each message type must have a well defined schema. The message schema is
also published to IoT Hub, so that backend applications reuse this information
to interpret the incoming telemetry.

The schema is used also by the simulation engine, to serialize the values
generated by the custom functions.

The schema supports JSON format, which allows for easy parsing,
transformation and analytics, across several systems and services.

The fields listed in the schema can be of the following types:

* Object - serialized using JSON
* Binary - serialized using base64
* Text
* Boolean
* Integer
* Double
* DateTime

#### Supported methods

Simulated devices can also react to method calls, in which case they will
execute some logic and provide some response. The actions to take are listed
in the following configuration block. The output of each action is collected
and returned as in the method response.
```json
"CloudToDeviceMethods": {
    "Reboot": {
        "Actions": [
            "${do_reboot}"
        ]
    },
    "Upgrade": {
        "Actions": [
            "${do_reboot}",
            "${do_upgrade}",
            "${do_reboot}"
        ]
    }
}
```

Function script files
=====================

The application supports functions stored in Javascript files, and executes
the scripts at runtime. Each Javascript file should contain a `getTelemetry`
function, with the following signature:

```javascript
function getTelemetry(deviceId, frequencyMsecs, currentTime)
{
    // Example of parameters:
    //  deviceId = "a-chiller-1002"
    //  frequencyMsecs = 5000
    //  currentTime = "2025-09-20T13:24:59+00:00"

    // Some logic here, to generate a value
    // Data is returned as an object.
    // Multiple fields can be used and referenced in the message template.
    return { myValue: "some value generated by the function" };
}
```

The javascript function receives in input the ID of the device sending the
message, how frequently messages are sent, and the current time (as a
string - the value can be parsed using `new Date(currentTime)`).

The value returned by the function is inserted in the message
template. For instance if this is the message template:

```
"{\"temperature\": \"${get_random_temperature.myValue}\" }"
```

the service will invoke the function `getValueAsString` from the javascript
file configured for `get_random_temperature` and replace
`${get_random_temperature.myValue}` with the `myValue` field in the object
returned by `getTelemetry()`.

Note: functions are supposed to be stateless, i.e. any data persisted in
memory is not carried over from one call to the next.
